//! Lock file handling
//!
//! The lock file (zigroot.lock) records exact versions and checksums
//! for reproducible builds.

use serde::{Deserialize, Serialize};
use std::path::Path;
use thiserror::Error;

/// Lock file errors
#[derive(Error, Debug)]
pub enum LockError {
    /// IO error
    #[error("Failed to read/write lock file '{path}': {error}")]
    IoError { path: String, error: String },

    /// Parse error
    #[error("Failed to parse lock file: {error}")]
    ParseError { error: String },

    /// Serialize error
    #[error("Failed to serialize lock file: {error}")]
    SerializeError { error: String },

    /// Package mismatch in locked mode
    #[error("Package '{name}' differs from lock file: {reason}")]
    PackageMismatch { name: String, reason: String },

    /// Package not in lock file
    #[error("Package '{name}' not found in lock file (run without --locked to update)")]
    PackageNotLocked { name: String },

    /// Zig version mismatch (warning, not error)
    #[error("Zig version mismatch: lock file has '{locked}', current is '{current}'")]
    ZigVersionMismatch { locked: String, current: String },
}

/// Lock file metadata
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct LockMetadata {
    /// Zigroot CLI version that generated this lock file
    pub zigroot_version: String,
    /// Zig compiler version used
    pub zig_version: String,
    /// When the lock file was generated
    pub generated: String,
}

/// A locked package entry
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct LockedPackage {
    /// Package name
    pub name: String,
    /// Exact version
    pub version: String,
    /// SHA256 checksum of source
    pub sha256: String,
    /// Source URI (omitted for registry, or "path:<path>", "git:<url>#<ref>", "registry:<url>")
    #[serde(skip_serializing_if = "Option::is_none")]
    pub source: Option<String>,
    /// Resolved dependencies with exact versions (e.g., ["zlib@1.2.13"])
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub depends: Vec<String>,
    /// Git commit SHA (for git sources with branch)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub git_sha: Option<String>,
}

/// A locked external artifact
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct LockedExternal {
    /// Artifact name
    pub name: String,
    /// Artifact type (bootloader, `partition_table`, etc.)
    #[serde(rename = "type")]
    pub artifact_type: String,
    /// SHA256 checksum
    pub sha256: String,
    /// Download URL
    pub url: String,
}

/// Lock file structure
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct LockFile {
    /// Lock file metadata
    pub metadata: LockMetadata,
    /// Locked packages (using `BTreeMap` for deterministic ordering)
    #[serde(default, rename = "package")]
    pub packages: Vec<LockedPackage>,
    /// Locked external artifacts
    #[serde(default, rename = "external", skip_serializing_if = "Vec::is_empty")]
    pub externals: Vec<LockedExternal>,
}

impl LockFile {
    /// Create a new lock file
    pub fn new(zigroot_version: &str, zig_version: &str) -> Self {
        let generated = chrono_lite_now();
        Self {
            metadata: LockMetadata {
                zigroot_version: zigroot_version.to_string(),
                zig_version: zig_version.to_string(),
                generated,
            },
            packages: Vec::new(),
            externals: Vec::new(),
        }
    }

    /// Load lock file from path
    pub fn load(path: &Path) -> Result<Self, LockError> {
        let content = std::fs::read_to_string(path).map_err(|e| LockError::IoError {
            path: path.display().to_string(),
            error: e.to_string(),
        })?;
        Self::from_toml(&content)
    }

    /// Save lock file to path
    pub fn save(&self, path: &Path) -> Result<(), LockError> {
        let content = self.to_toml()?;

        // Add header comment
        let header = "# This file is auto-generated by zigroot. Do not edit manually.\n\
                      # Run 'zigroot update' to update locked versions.\n\n";
        let full_content = format!("{header}{content}");

        std::fs::write(path, full_content).map_err(|e| LockError::IoError {
            path: path.display().to_string(),
            error: e.to_string(),
        })?;
        Ok(())
    }

    /// Parse from TOML string
    pub fn from_toml(content: &str) -> Result<Self, LockError> {
        toml::from_str(content).map_err(|e| LockError::ParseError {
            error: e.to_string(),
        })
    }

    /// Serialize to TOML string
    pub fn to_toml(&self) -> Result<String, LockError> {
        toml::to_string_pretty(self).map_err(|e| LockError::SerializeError {
            error: e.to_string(),
        })
    }

    /// Add a locked package
    pub fn add_package(&mut self, package: LockedPackage) {
        // Remove existing package with same name
        self.packages.retain(|p| p.name != package.name);
        self.packages.push(package);
        // Sort for deterministic output
        self.packages.sort_by(|a, b| a.name.cmp(&b.name));
    }

    /// Add a locked external artifact
    pub fn add_external(&mut self, external: LockedExternal) {
        self.externals.retain(|e| e.name != external.name);
        self.externals.push(external);
        self.externals.sort_by(|a, b| a.name.cmp(&b.name));
    }

    /// Get a locked package by name
    pub fn get_package(&self, name: &str) -> Option<&LockedPackage> {
        self.packages.iter().find(|p| p.name == name)
    }

    /// Get a locked external by name
    pub fn get_external(&self, name: &str) -> Option<&LockedExternal> {
        self.externals.iter().find(|e| e.name == name)
    }

    /// Check if Zig version matches
    pub fn check_zig_version(&self, current_version: &str) -> Option<LockError> {
        if self.metadata.zig_version == current_version {
            None
        } else {
            Some(LockError::ZigVersionMismatch {
                locked: self.metadata.zig_version.clone(),
                current: current_version.to_string(),
            })
        }
    }

    /// Verify a package matches the lock file (for --locked mode)
    pub fn verify_package(&self, name: &str, version: &str, sha256: &str) -> Result<(), LockError> {
        let locked = self
            .get_package(name)
            .ok_or_else(|| LockError::PackageNotLocked {
                name: name.to_string(),
            })?;

        if locked.version != version {
            return Err(LockError::PackageMismatch {
                name: name.to_string(),
                reason: format!(
                    "version mismatch: locked '{}', got '{}'",
                    locked.version, version
                ),
            });
        }

        if locked.sha256 != sha256 && locked.sha256 != "local" {
            return Err(LockError::PackageMismatch {
                name: name.to_string(),
                reason: format!(
                    "checksum mismatch: locked '{}', got '{}'",
                    locked.sha256, sha256
                ),
            });
        }

        Ok(())
    }

    /// Get all package names
    pub fn package_names(&self) -> Vec<&str> {
        self.packages.iter().map(|p| p.name.as_str()).collect()
    }
}

impl Default for LockFile {
    fn default() -> Self {
        Self::new("0.0.0", "unknown")
    }
}

/// Simple timestamp generation (avoiding chrono dependency)
fn chrono_lite_now() -> String {
    use std::time::{SystemTime, UNIX_EPOCH};
    let duration = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap_or_default();
    let secs = duration.as_secs();

    // Convert to ISO 8601 format (simplified)
    let days_since_epoch = secs / 86400;
    let time_of_day = secs % 86400;

    // Approximate year/month/day calculation
    let years = days_since_epoch / 365;
    let year = 1970 + years;
    let remaining_days = days_since_epoch % 365;
    let month = (remaining_days / 30) + 1;
    let day = (remaining_days % 30) + 1;

    let hours = time_of_day / 3600;
    let minutes = (time_of_day % 3600) / 60;
    let seconds = time_of_day % 60;

    format!(
        "{:04}-{:02}-{:02}T{:02}:{:02}:{:02}Z",
        year,
        month.min(12),
        day.min(31),
        hours,
        minutes,
        seconds
    )
}

/// Builder for creating locked packages
#[derive(Debug, Default)]
pub struct LockedPackageBuilder {
    name: String,
    version: String,
    sha256: String,
    source: Option<String>,
    depends: Vec<String>,
    git_sha: Option<String>,
}

impl LockedPackageBuilder {
    /// Create a new builder
    pub fn new(name: &str, version: &str, sha256: &str) -> Self {
        Self {
            name: name.to_string(),
            version: version.to_string(),
            sha256: sha256.to_string(),
            ..Default::default()
        }
    }

    /// Set source (for non-registry packages)
    pub fn source(mut self, source: &str) -> Self {
        self.source = Some(source.to_string());
        self
    }

    /// Add a dependency
    pub fn depends(mut self, dep: &str) -> Self {
        self.depends.push(dep.to_string());
        self
    }

    /// Set git SHA (for git+branch sources)
    pub fn git_sha(mut self, sha: &str) -> Self {
        self.git_sha = Some(sha.to_string());
        self
    }

    /// Build the locked package
    pub fn build(self) -> LockedPackage {
        LockedPackage {
            name: self.name,
            version: self.version,
            sha256: self.sha256,
            source: self.source,
            depends: self.depends,
            git_sha: self.git_sha,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use proptest::prelude::*;
    use tempfile::TempDir;

    // ============================================
    // Unit Tests - LockFile creation
    // ============================================

    #[test]
    fn test_lock_file_new() {
        let lock = LockFile::new("0.1.0", "0.13.0");
        assert_eq!(lock.metadata.zigroot_version, "0.1.0");
        assert_eq!(lock.metadata.zig_version, "0.13.0");
        assert!(lock.packages.is_empty());
        assert!(lock.externals.is_empty());
    }

    #[test]
    fn test_lock_file_default() {
        let lock = LockFile::default();
        assert_eq!(lock.metadata.zigroot_version, "0.0.0");
        assert_eq!(lock.metadata.zig_version, "unknown");
    }

    // ============================================
    // Unit Tests - Lock file generates with exact versions and checksums
    // ============================================

    #[test]
    fn test_lock_file_generates_with_exact_versions() {
        let mut lock = LockFile::new("0.1.0", "0.13.0");

        lock.add_package(LockedPackage {
            name: "busybox".to_string(),
            version: "1.36.1".to_string(),
            sha256: "b8cc24c9574d809e7279c3be349795c5d5ceb6fdf19ca709f80cde50e47de314".to_string(),
            source: None,
            depends: vec![],
            git_sha: None,
        });

        let pkg = lock.get_package("busybox").unwrap();
        assert_eq!(pkg.version, "1.36.1");
        assert_eq!(
            pkg.sha256,
            "b8cc24c9574d809e7279c3be349795c5d5ceb6fdf19ca709f80cde50e47de314"
        );
    }

    #[test]
    fn test_lock_file_generates_with_checksums() {
        let mut lock = LockFile::new("0.1.0", "0.13.0");

        let checksum = "abc123def456789012345678901234567890123456789012345678901234";
        lock.add_package(LockedPackageBuilder::new("mypackage", "1.0.0", checksum).build());

        let pkg = lock.get_package("mypackage").unwrap();
        assert_eq!(pkg.sha256, checksum);
    }

    // ============================================
    // Unit Tests - Lock file records Zig compiler version
    // ============================================

    #[test]
    fn test_lock_file_records_zig_version() {
        let lock = LockFile::new("0.1.0", "0.13.0");
        assert_eq!(lock.metadata.zig_version, "0.13.0");
    }

    #[test]
    fn test_lock_file_zig_version_in_toml() {
        let lock = LockFile::new("0.1.0", "0.13.0");
        let toml = lock.to_toml().unwrap();

        assert!(
            toml.contains("zig_version = \"0.13.0\""),
            "TOML should contain zig_version"
        );
    }

    // ============================================
    // Unit Tests - Lock file records source URIs correctly
    // ============================================

    #[test]
    fn test_lock_file_source_registry_default() {
        let mut lock = LockFile::new("0.1.0", "0.13.0");

        // Registry source is the default, should be None (omitted)
        lock.add_package(LockedPackageBuilder::new("busybox", "1.36.1", "abc123").build());

        let pkg = lock.get_package("busybox").unwrap();
        assert!(pkg.source.is_none(), "Registry source should be omitted");
    }

    #[test]
    fn test_lock_file_source_path() {
        let mut lock = LockFile::new("0.1.0", "0.13.0");

        lock.add_package(
            LockedPackageBuilder::new("myapp", "0.1.0", "local")
                .source("path:packages/myapp")
                .build(),
        );

        let pkg = lock.get_package("myapp").unwrap();
        assert_eq!(pkg.source, Some("path:packages/myapp".to_string()));
    }

    #[test]
    fn test_lock_file_source_git() {
        let mut lock = LockFile::new("0.1.0", "0.13.0");

        lock.add_package(
            LockedPackageBuilder::new("forked-nginx", "1.24.0", "def456")
                .source("git:https://github.com/myorg/nginx-fork#v1.24.0")
                .build(),
        );

        let pkg = lock.get_package("forked-nginx").unwrap();
        assert_eq!(
            pkg.source,
            Some("git:https://github.com/myorg/nginx-fork#v1.24.0".to_string())
        );
    }

    #[test]
    fn test_lock_file_source_custom_registry() {
        let mut lock = LockFile::new("0.1.0", "0.13.0");

        lock.add_package(
            LockedPackageBuilder::new("private-lib", "2.0.0", "abc123")
                .source("registry:https://packages.mycompany.com")
                .build(),
        );

        let pkg = lock.get_package("private-lib").unwrap();
        assert_eq!(
            pkg.source,
            Some("registry:https://packages.mycompany.com".to_string())
        );
    }

    // ============================================
    // Unit Tests - --locked mode uses locked versions
    // ============================================

    #[test]
    fn test_locked_mode_uses_locked_versions() {
        let mut lock = LockFile::new("0.1.0", "0.13.0");
        lock.add_package(LockedPackageBuilder::new("busybox", "1.36.1", "abc123").build());

        // Verify package matches
        let result = lock.verify_package("busybox", "1.36.1", "abc123");
        assert!(result.is_ok(), "Should accept matching package");
    }

    #[test]
    fn test_locked_mode_returns_locked_package() {
        let mut lock = LockFile::new("0.1.0", "0.13.0");
        lock.add_package(
            LockedPackageBuilder::new("busybox", "1.36.1", "abc123")
                .depends("zlib@1.2.13")
                .build(),
        );

        let pkg = lock.get_package("busybox").unwrap();
        assert_eq!(pkg.version, "1.36.1");
        assert_eq!(pkg.depends, vec!["zlib@1.2.13"]);
    }

    // ============================================
    // Unit Tests - --locked mode fails if package differs
    // ============================================

    #[test]
    fn test_locked_mode_fails_version_mismatch() {
        let mut lock = LockFile::new("0.1.0", "0.13.0");
        lock.add_package(LockedPackageBuilder::new("busybox", "1.36.1", "abc123").build());

        let result = lock.verify_package("busybox", "1.36.0", "abc123");
        assert!(result.is_err());
        match result.unwrap_err() {
            LockError::PackageMismatch { name, reason } => {
                assert_eq!(name, "busybox");
                assert!(reason.contains("version mismatch"));
            }
            e => panic!("Expected PackageMismatch, got: {e:?}"),
        }
    }

    #[test]
    fn test_locked_mode_fails_checksum_mismatch() {
        let mut lock = LockFile::new("0.1.0", "0.13.0");
        lock.add_package(LockedPackageBuilder::new("busybox", "1.36.1", "abc123").build());

        let result = lock.verify_package("busybox", "1.36.1", "different_checksum");
        assert!(result.is_err());
        match result.unwrap_err() {
            LockError::PackageMismatch { name, reason } => {
                assert_eq!(name, "busybox");
                assert!(reason.contains("checksum mismatch"));
            }
            e => panic!("Expected PackageMismatch, got: {e:?}"),
        }
    }

    #[test]
    fn test_locked_mode_fails_package_not_in_lock() {
        let lock = LockFile::new("0.1.0", "0.13.0");

        let result = lock.verify_package("nonexistent", "1.0.0", "abc123");
        assert!(result.is_err());
        match result.unwrap_err() {
            LockError::PackageNotLocked { name } => {
                assert_eq!(name, "nonexistent");
            }
            e => panic!("Expected PackageNotLocked, got: {e:?}"),
        }
    }

    // ============================================
    // Unit Tests - Git branch SHA recorded for reproducibility
    // ============================================

    #[test]
    fn test_git_branch_sha_recorded() {
        let mut lock = LockFile::new("0.1.0", "0.13.0");

        lock.add_package(
            LockedPackageBuilder::new("forked-lib", "1.0.0", "abc123")
                .source("git:https://github.com/user/repo#main")
                .git_sha("abc123def456789012345678901234567890abcd")
                .build(),
        );

        let pkg = lock.get_package("forked-lib").unwrap();
        assert_eq!(
            pkg.git_sha,
            Some("abc123def456789012345678901234567890abcd".to_string())
        );
    }

    #[test]
    fn test_git_sha_in_toml() {
        let mut lock = LockFile::new("0.1.0", "0.13.0");

        lock.add_package(
            LockedPackageBuilder::new("forked-lib", "1.0.0", "abc123")
                .source("git:https://github.com/user/repo#main")
                .git_sha("abc123def456789012345678901234567890abcd")
                .build(),
        );

        let toml = lock.to_toml().unwrap();
        assert!(
            toml.contains("git_sha = \"abc123def456789012345678901234567890abcd\""),
            "TOML should contain git_sha"
        );
    }

    // ============================================
    // Unit Tests - Zig version mismatch produces warning
    // ============================================

    #[test]
    fn test_zig_version_mismatch_warning() {
        let lock = LockFile::new("0.1.0", "0.13.0");

        let warning = lock.check_zig_version("0.12.0");
        assert!(warning.is_some());

        match warning.unwrap() {
            LockError::ZigVersionMismatch { locked, current } => {
                assert_eq!(locked, "0.13.0");
                assert_eq!(current, "0.12.0");
            }
            e => panic!("Expected ZigVersionMismatch, got: {e:?}"),
        }
    }

    #[test]
    fn test_zig_version_match_no_warning() {
        let lock = LockFile::new("0.1.0", "0.13.0");

        let warning = lock.check_zig_version("0.13.0");
        assert!(warning.is_none());
    }

    // ============================================
    // Unit Tests - TOML serialization/deserialization
    // ============================================

    #[test]
    fn test_lock_file_roundtrip() {
        let mut lock = LockFile::new("0.1.0", "0.13.0");

        lock.add_package(
            LockedPackageBuilder::new("busybox", "1.36.1", "abc123")
                .depends("zlib@1.2.13")
                .build(),
        );

        lock.add_package(
            LockedPackageBuilder::new("myapp", "0.1.0", "local")
                .source("path:packages/myapp")
                .depends("busybox@1.36.1")
                .build(),
        );

        lock.add_external(LockedExternal {
            name: "u-boot".to_string(),
            artifact_type: "bootloader".to_string(),
            sha256: "def456".to_string(),
            url: "https://example.com/u-boot.bin".to_string(),
        });

        let toml = lock.to_toml().unwrap();
        let parsed = LockFile::from_toml(&toml).unwrap();

        assert_eq!(parsed.metadata.zig_version, "0.13.0");
        assert_eq!(parsed.packages.len(), 2);
        assert_eq!(parsed.externals.len(), 1);

        let busybox = parsed.get_package("busybox").unwrap();
        assert_eq!(busybox.version, "1.36.1");
        assert_eq!(busybox.depends, vec!["zlib@1.2.13"]);
    }

    // ============================================
    // Unit Tests - File I/O
    // ============================================

    #[test]
    fn test_lock_file_save_and_load() {
        let temp = TempDir::new().unwrap();
        let lock_path = temp.path().join("zigroot.lock");

        let mut lock = LockFile::new("0.1.0", "0.13.0");
        lock.add_package(LockedPackageBuilder::new("busybox", "1.36.1", "abc123").build());

        // Save
        lock.save(&lock_path).unwrap();
        assert!(lock_path.exists());

        // Load
        let loaded = LockFile::load(&lock_path).unwrap();
        assert_eq!(loaded.metadata.zig_version, "0.13.0");
        assert!(loaded.get_package("busybox").is_some());
    }

    #[test]
    fn test_lock_file_has_header_comment() {
        let temp = TempDir::new().unwrap();
        let lock_path = temp.path().join("zigroot.lock");

        let lock = LockFile::new("0.1.0", "0.13.0");
        lock.save(&lock_path).unwrap();

        let content = std::fs::read_to_string(&lock_path).unwrap();
        assert!(content.starts_with("# This file is auto-generated"));
    }

    // ============================================
    // Unit Tests - Package ordering (deterministic)
    // ============================================

    #[test]
    fn test_packages_sorted_alphabetically() {
        let mut lock = LockFile::new("0.1.0", "0.13.0");

        // Add in non-alphabetical order
        lock.add_package(LockedPackageBuilder::new("zlib", "1.2.13", "aaa").build());
        lock.add_package(LockedPackageBuilder::new("busybox", "1.36.1", "bbb").build());
        lock.add_package(LockedPackageBuilder::new("dropbear", "2024.85", "ccc").build());

        let names: Vec<_> = lock.packages.iter().map(|p| p.name.as_str()).collect();
        assert_eq!(names, vec!["busybox", "dropbear", "zlib"]);
    }

    // ============================================
    // Unit Tests - External artifacts
    // ============================================

    #[test]
    fn test_external_artifacts() {
        let mut lock = LockFile::new("0.1.0", "0.13.0");

        lock.add_external(LockedExternal {
            name: "u-boot".to_string(),
            artifact_type: "bootloader".to_string(),
            sha256: "abc123".to_string(),
            url: "https://example.com/u-boot.bin".to_string(),
        });

        let ext = lock.get_external("u-boot").unwrap();
        assert_eq!(ext.artifact_type, "bootloader");
        assert_eq!(ext.sha256, "abc123");
    }

    // ============================================
    // Property-Based Tests
    // ============================================

    /// Strategy for generating package names
    fn package_name_strategy() -> impl Strategy<Value = String> {
        proptest::string::string_regex("[a-z][a-z0-9-]{0,29}")
            .unwrap()
            .prop_filter("non-empty", |s| !s.is_empty())
    }

    /// Strategy for generating version strings
    fn version_strategy() -> impl Strategy<Value = String> {
        proptest::string::string_regex("[0-9]+\\.[0-9]+\\.[0-9]+").unwrap()
    }

    /// Strategy for generating SHA256 checksums
    fn sha256_strategy() -> impl Strategy<Value = String> {
        proptest::string::string_regex("[0-9a-f]{64}").unwrap()
    }

    proptest! {
        #![proptest_config(ProptestConfig::with_cases(100))]

        /// Feature: zigroot-cli, Property 12: Lock File Reproducibility
        /// For any project with a lock file, building with --locked SHALL use
        /// exactly the versions specified in the lock file.
        /// **Validates: Requirements 13.2, 13.3**
        #[test]
        fn prop_lock_file_reproducibility(
            name in package_name_strategy(),
            version in version_strategy(),
            sha256 in sha256_strategy(),
        ) {
            let mut lock = LockFile::new("0.1.0", "0.13.0");
            lock.add_package(LockedPackageBuilder::new(&name, &version, &sha256).build());

            // Verify exact match succeeds
            let result = lock.verify_package(&name, &version, &sha256);
            prop_assert!(result.is_ok(), "Exact match should succeed");

            // Verify different version fails
            let different_version = format!("{}.1", version);
            let result = lock.verify_package(&name, &different_version, &sha256);
            prop_assert!(result.is_err(), "Different version should fail");

            // Verify different checksum fails
            let different_sha = "0".repeat(64);
            if sha256 != different_sha {
                let result = lock.verify_package(&name, &version, &different_sha);
                prop_assert!(result.is_err(), "Different checksum should fail");
            }
        }

        /// Feature: zigroot-cli, Property 26: Zig Version Recording
        /// For any build, the lock file SHALL record the Zig compiler version used,
        /// and a warning SHALL be displayed if the current version differs.
        /// **Validates: Requirements 13.4, 13.5**
        #[test]
        fn prop_zig_version_recording(
            zig_version in version_strategy(),
            current_version in version_strategy(),
        ) {
            let lock = LockFile::new("0.1.0", &zig_version);

            // Verify Zig version is recorded
            prop_assert_eq!(&lock.metadata.zig_version, &zig_version);

            // Verify warning when versions differ
            let warning = lock.check_zig_version(&current_version);
            if zig_version == current_version {
                prop_assert!(warning.is_none(), "Same version should not warn");
            } else {
                prop_assert!(warning.is_some(), "Different version should warn");
            }
        }

        /// Property: Lock file TOML roundtrip preserves data
        #[test]
        fn prop_lock_file_toml_roundtrip(
            name in package_name_strategy(),
            version in version_strategy(),
            sha256 in sha256_strategy(),
        ) {
            let mut lock = LockFile::new("0.1.0", "0.13.0");
            lock.add_package(LockedPackageBuilder::new(&name, &version, &sha256).build());

            let toml = lock.to_toml().unwrap();
            let parsed = LockFile::from_toml(&toml).unwrap();

            let original_pkg = lock.get_package(&name).unwrap();
            let parsed_pkg = parsed.get_package(&name).unwrap();

            prop_assert_eq!(&original_pkg.version, &parsed_pkg.version);
            prop_assert_eq!(&original_pkg.sha256, &parsed_pkg.sha256);
        }

        /// Property: Package names are unique in lock file
        #[test]
        fn prop_package_names_unique(
            name in package_name_strategy(),
            version1 in version_strategy(),
            version2 in version_strategy(),
        ) {
            let mut lock = LockFile::new("0.1.0", "0.13.0");

            // Add same package twice with different versions
            lock.add_package(LockedPackageBuilder::new(&name, &version1, "aaa").build());
            lock.add_package(LockedPackageBuilder::new(&name, &version2, "bbb").build());

            // Should only have one entry (the second one)
            let count = lock.packages.iter().filter(|p| p.name == name).count();
            prop_assert_eq!(count, 1, "Package name should be unique");

            let pkg = lock.get_package(&name).unwrap();
            prop_assert_eq!(&pkg.version, &version2, "Should have the latest version");
        }
    }
}
