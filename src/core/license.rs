//! License compliance logic
//!
//! Tracks and reports licenses of all included packages.
//!
//! **Validates: Requirements 22.1-22.6**

use std::collections::HashMap;
use std::path::Path;

use crate::core::manifest::Manifest;

/// License information for a package
#[derive(Debug, Clone)]
pub struct PackageLicense {
    /// Package name
    pub name: String,
    /// Package version
    pub version: String,
    /// License identifier (SPDX format)
    pub license: Option<String>,
    /// Source URL
    pub source_url: Option<String>,
    /// Whether this is a copyleft license
    pub is_copyleft: bool,
}

impl PackageLicense {
    /// Create a new package license entry
    pub fn new(name: &str, version: &str, license: Option<&str>, source_url: Option<&str>) -> Self {
        let is_copyleft = license
            .map(|l| is_copyleft_license(l))
            .unwrap_or(false);

        Self {
            name: name.to_string(),
            version: version.to_string(),
            license: license.map(String::from),
            source_url: source_url.map(String::from),
            is_copyleft,
        }
    }
}

/// Check if a license is copyleft
pub fn is_copyleft_license(license: &str) -> bool {
    let copyleft_licenses = [
        "GPL",
        "GPL-2.0",
        "GPL-3.0",
        "LGPL",
        "LGPL-2.0",
        "LGPL-2.1",
        "LGPL-3.0",
        "AGPL",
        "AGPL-3.0",
        "MPL",
        "MPL-2.0",
        "CC-BY-SA",
        "CDDL",
        "EPL",
    ];

    let license_upper = license.to_uppercase();
    copyleft_licenses
        .iter()
        .any(|cl| license_upper.contains(&cl.to_uppercase()))
}

/// License report for a project
#[derive(Debug, Default)]
pub struct LicenseReport {
    /// Package licenses
    pub packages: Vec<PackageLicense>,
    /// Packages with missing license info
    pub missing_licenses: Vec<String>,
    /// Packages with copyleft licenses
    pub copyleft_packages: Vec<String>,
}

impl LicenseReport {
    /// Create a new empty report
    pub fn new() -> Self {
        Self::default()
    }

    /// Add a package license
    pub fn add_package(&mut self, pkg: PackageLicense) {
        if pkg.license.is_none() {
            self.missing_licenses.push(pkg.name.clone());
        }
        if pkg.is_copyleft {
            self.copyleft_packages.push(pkg.name.clone());
        }
        self.packages.push(pkg);
    }

    /// Check if there are any warnings
    pub fn has_warnings(&self) -> bool {
        !self.missing_licenses.is_empty() || !self.copyleft_packages.is_empty()
    }

    /// Generate license summary text
    pub fn summary(&self) -> String {
        let mut lines = Vec::new();

        lines.push(format!("License Summary: {} packages\n", self.packages.len()));

        // Group by license
        let mut by_license: HashMap<String, Vec<&PackageLicense>> = HashMap::new();
        for pkg in &self.packages {
            let key = pkg.license.clone().unwrap_or_else(|| "Unknown".to_string());
            by_license.entry(key).or_default().push(pkg);
        }

        for (license, pkgs) in &by_license {
            let copyleft_marker = if is_copyleft_license(license) {
                " ⚠️ (copyleft)"
            } else {
                ""
            };
            lines.push(format!("\n{license}{copyleft_marker}:"));
            for pkg in pkgs {
                lines.push(format!("  • {} v{}", pkg.name, pkg.version));
            }
        }

        if !self.missing_licenses.is_empty() {
            lines.push(format!(
                "\n⚠️  Missing license info: {}",
                self.missing_licenses.join(", ")
            ));
        }

        if !self.copyleft_packages.is_empty() {
            lines.push(format!(
                "\n⚠️  Copyleft licenses detected: {}",
                self.copyleft_packages.join(", ")
            ));
        }

        lines.join("\n")
    }

    /// Generate license report for export
    pub fn export_report(&self) -> String {
        let mut lines = Vec::new();

        lines.push("# License Report\n".to_string());
        lines.push(format!("Generated by Zigroot\n"));
        lines.push(format!("Total packages: {}\n", self.packages.len()));

        lines.push("\n## Package Licenses\n".to_string());

        for pkg in &self.packages {
            lines.push(format!("### {}\n", pkg.name));
            lines.push(format!("- Version: {}", pkg.version));
            lines.push(format!(
                "- License: {}",
                pkg.license.as_deref().unwrap_or("Unknown")
            ));
            if let Some(url) = &pkg.source_url {
                lines.push(format!("- Source: {url}"));
            }
            if pkg.is_copyleft {
                lines.push("- ⚠️ Copyleft license".to_string());
            }
            lines.push(String::new());
        }

        if !self.missing_licenses.is_empty() {
            lines.push("\n## Warnings\n".to_string());
            lines.push("The following packages are missing license information:".to_string());
            for pkg in &self.missing_licenses {
                lines.push(format!("- {pkg}"));
            }
        }

        lines.join("\n")
    }

    /// Generate SPDX SBOM
    pub fn generate_sbom(&self, project_name: &str) -> String {
        let mut lines = Vec::new();

        // SPDX header
        lines.push("SPDXVersion: SPDX-2.3".to_string());
        lines.push("DataLicense: CC0-1.0".to_string());
        lines.push(format!("SPDXID: SPDXRef-DOCUMENT"));
        lines.push(format!("DocumentName: {project_name}-sbom"));
        lines.push(format!(
            "DocumentNamespace: https://zigroot.dev/sbom/{project_name}"
        ));
        lines.push("Creator: Tool: zigroot".to_string());
        lines.push(String::new());

        // Package info
        for (i, pkg) in self.packages.iter().enumerate() {
            lines.push(format!("##### Package: {}", pkg.name));
            lines.push(format!("PackageName: {}", pkg.name));
            lines.push(format!("SPDXID: SPDXRef-Package-{i}"));
            lines.push(format!("PackageVersion: {}", pkg.version));
            if let Some(url) = &pkg.source_url {
                lines.push(format!("PackageDownloadLocation: {url}"));
            } else {
                lines.push("PackageDownloadLocation: NOASSERTION".to_string());
            }
            lines.push(format!(
                "PackageLicenseConcluded: {}",
                pkg.license.as_deref().unwrap_or("NOASSERTION")
            ));
            lines.push(format!(
                "PackageLicenseDeclared: {}",
                pkg.license.as_deref().unwrap_or("NOASSERTION")
            ));
            lines.push("PackageCopyrightText: NOASSERTION".to_string());
            lines.push(String::new());
        }

        lines.join("\n")
    }
}

/// Collect license information from project
pub fn collect_licenses(project_dir: &Path, manifest: &Manifest) -> LicenseReport {
    let mut report = LicenseReport::new();

    // Collect from manifest packages
    for (name, pkg_ref) in &manifest.packages {
        let version = pkg_ref.version.clone().unwrap_or_else(|| "unknown".to_string());

        // Try to load local package definition
        let local_pkg_path = project_dir.join("packages").join(name).join("package.toml");
        let license = if local_pkg_path.exists() {
            load_package_license(&local_pkg_path)
        } else {
            None
        };

        let source_url = pkg_ref.git.clone();

        report.add_package(PackageLicense::new(
            name,
            &version,
            license.as_deref(),
            source_url.as_deref(),
        ));
    }

    report
}

/// Load license from a package definition file
fn load_package_license(path: &Path) -> Option<String> {
    let content = std::fs::read_to_string(path).ok()?;
    let table: toml::Table = content.parse().ok()?;

    table
        .get("package")
        .and_then(|p| p.get("license"))
        .and_then(|l| l.as_str())
        .map(String::from)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_is_copyleft_license() {
        assert!(is_copyleft_license("GPL-2.0"));
        assert!(is_copyleft_license("GPL-3.0"));
        assert!(is_copyleft_license("LGPL-2.1"));
        assert!(is_copyleft_license("AGPL-3.0"));
        assert!(is_copyleft_license("MPL-2.0"));

        assert!(!is_copyleft_license("MIT"));
        assert!(!is_copyleft_license("Apache-2.0"));
        assert!(!is_copyleft_license("BSD-3-Clause"));
        assert!(!is_copyleft_license("ISC"));
    }

    #[test]
    fn test_package_license_new() {
        let pkg = PackageLicense::new("test", "1.0.0", Some("MIT"), Some("https://example.com"));
        assert_eq!(pkg.name, "test");
        assert_eq!(pkg.version, "1.0.0");
        assert_eq!(pkg.license, Some("MIT".to_string()));
        assert!(!pkg.is_copyleft);

        let gpl_pkg = PackageLicense::new("gpl-test", "1.0.0", Some("GPL-2.0"), None);
        assert!(gpl_pkg.is_copyleft);
    }

    #[test]
    fn test_license_report_summary() {
        let mut report = LicenseReport::new();
        report.add_package(PackageLicense::new("pkg1", "1.0.0", Some("MIT"), None));
        report.add_package(PackageLicense::new("pkg2", "2.0.0", Some("GPL-2.0"), None));
        report.add_package(PackageLicense::new("pkg3", "1.0.0", None, None));

        let summary = report.summary();
        assert!(summary.contains("MIT"));
        assert!(summary.contains("GPL-2.0"));
        assert!(summary.contains("copyleft"));
        assert!(summary.contains("Missing license"));
    }

    #[test]
    fn test_license_report_sbom() {
        let mut report = LicenseReport::new();
        report.add_package(PackageLicense::new(
            "test-pkg",
            "1.0.0",
            Some("MIT"),
            Some("https://example.com/test.tar.gz"),
        ));

        let sbom = report.generate_sbom("test-project");
        assert!(sbom.contains("SPDX"));
        assert!(sbom.contains("test-pkg"));
        assert!(sbom.contains("MIT"));
    }
}
